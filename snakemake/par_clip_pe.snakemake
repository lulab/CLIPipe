include: './0_common.snakemake'

root_dir = config.get("root_dir")
output_dir = config.get("output_dir")
summary_dir = config.get('summary_dir')

def get_all_inputs(wildcards):
    available_inputs = dict(
        # fastqc_raw
        fastqc_raw_html=expand('{output_dir}/fastqc_raw/{sample_id}_fastqc.html', output_dir=output_dir, sample_id=sample_ids),
        fastqc_raw_zip=expand('{output_dir}/fastqc_raw/{sample_id}_fastqc.zip', output_dir=output_dir, sample_id=sample_ids),
        # multiqc_raw
        multiqc_raw_html=expand('{output_dir}/multiqc_raw/multiqc_report.html', output_dir=output_dir),
        # pre_process
        fastq_pre_porcess=expand('{output_dir}/pre_process/{sample_id}.clipped.filtered.collapsed.trimmed.fa',output_dir=output_dir, sample_id=sample_ids),
    )
    enabled_inputs = list(available_inputs.keys())
    inputs = []
    for key, l in available_inputs.items():
        if key in enabled_inputs:
            inputs += l
    return inputs

rule all:
    input:
        get_all_inputs

###------------------------The output section---------------------------###
    
rule fastqc_raw:
    input:
        auto_gzip_input(config.get('data_dir') + '/fastq/{sample_id}.fastq')
    output:
        html='{output_dir}/fastqc_raw/{sample_id}_fastqc.html',
        zip='{output_dir}/fastqc_raw/{sample_id}_fastqc.zip'
    params:
        output_prefix='{output_dir}/fastqc_raw/',
    threads:
        1
    # conda:
    #     "./envs/quality_control.yaml"
    log:
        '{output_dir}/log/quality_control_raw/fastqc/{sample_id}.log'
    shell:
        ''' fastqc -f fastq -o {params.output_prefix} {input} > {log} 2>&1
        '''


rule multiqc_raw:
    input:
        fastqc=expand('{output_dir}/fastqc_raw/{sample_id}_fastqc.zip',
            output_dir=output_dir, sample_id=sample_ids)
    output:
        multiqc_raw_html='{output_dir}/multiqc_raw/multiqc_report.html',
        multiqc_raw_general_stats='{output_dir}/multiqc_raw/multiqc_data/multiqc_general_stats.txt',
        multiqc_raw_txt='{output_dir}/multiqc_raw/multiqc_data/multiqc_fastqc.txt',
    params:
        fastqc_dir='{output_dir}/fastqc_raw',
        multiqc_out_dir='{output_dir}/multiqc_raw'
    threads:
        1
    # conda:
    #     "./envs/quality_control.yaml"
    log:
        '{output_dir}/log/quality_control_raw/multiqc.log'
    shell:
        '''multiqc -f -m fastqc -o {params.multiqc_out_dir} {params.fastqc_dir} > {log} 2>&1
        '''

rule fastq2fasta:
    input:
        raw_fastq=auto_gzip_input(config.get('data_dir') + '/fastq/{sample_id}.fastq')
    output:
        raw_fasta='{output_dir}/fasta_raw/{sample_id}.fasta'
    threads:
        1
    log:
        '{output_dir}/log/fastq2fasta/{sample_id}.log'
    shell:
        '''root_dir/parclip_suite/fastq2fasta.pl {input.raw_fastq} > {output.raw_fasta}
        '''


rule cut_adapter:
    input:
        raw_fasta='{output_dir}/fasta_raw/{sample_id}.fasta'
    output:
        trimmed_fasta='{output_dir}/fasta_trimmed/{sample_id}.fasta'
    params:
        3_end_adapter=config.get('3_end_adapter'),
        5_end_adapter=config.get('5_end_adapter'),
        anywhere_adapter_1=config.get('anywhere_adapter_1'),
        anywhere_adapter_2=config.get('anywhere_adapter_2'),
    threads:
        1
    log:
        '{output_dir}/log/cut_adapter/{sample_id}.log'
    shell:
        '''cutadapt {input.raw_fasta} \
                -a {params.3_end_adapter} \
                -g {params.5_end_adapter} \
                -b {params.anywhere_adapter_1} \
                -b {params.anywhere_adapter_2} > {output.trimmed_fasta}
        '''

rule collapse_fasta:
    input:
        trimmed_fasta='{output_dir}/fasta_trimmed/{sample_id}.fasta'
    output:
        collapsed_fasta='{output_dir}/fasta_collapsed/{sample_id}.fasta'
    threads:
        1
    log:
        '{output_dir}/log/collapse_fasta/{sample_id}.log'
    shell:
        '''root_dir/parclip_suite/fasta2unique.pl {input.trimmed_fasta} > {output.collapsed_fasta}
        '''

rule split_fasta:
    input:
        collapsed_fasta='{output_dir}/fasta_collapsed/{sample_id}.fasta'
    output:
        splited_fasta_dir='{output_dir}/fasta_splited/',
        split_fasta_list='{output_dir}/fasta_splited/{sample_id}_splited_fa.lst'
    params:
        minimal_length=config.get('minimal_length'),
        maximal_length=config.get('maximal_length'),
    threads:
        1
    log:
        '{output_dir}/log/fasta_splited/{sample_id}.log'
    run:
        import os

        bin=["AA","AT","AG","AC", "TA","TT","TG","TC", "CA","CT","CG","CC", "GA","GT","GG","GC"]

        for i in range(1,17):
            os.system(root_dir + '/parclip_suite/fasta_split_by_letter.pl ' + input.collapsed_fasta + ' ' + params.minimal_length + ' ' + bin[i] + ' > ' + output.splited_fasta_dir + sample_id + '_' + bin[i] + 'fa')

        os.system('ls ' + output.splited_fasta_dir + sample_id + '_' + bin[i] + 'fa > ' + output.split_fasta_list)

rule annotate_fasta_file:
    input:
        splited_fasta_dir='{output_dir}/fasta_splited/',
        split_fasta_list='{output_dir}/fasta_splited/{sample_id}_splited_fa.lst'
    output:
        annotate_dir='{output_dir}/annotate_dir/',
    params:

    threads:

    log:

    run:
        import os

        for i in range(1,17):
            os.system(root_dir + '/parclip_suite/annotate.pl ' + output.annotate_dir + ' ' + output.annotate_dir + sample_id + '_' + bin[i] + 'fa')


















rule clip_adapter:
    input:
        fastq=auto_gzip_input(config.get('data_dir') + '/fastq/{sample_id}.fastq'),
    output:
        fastq='{output_dir}/pre_process/{sample_id}.clipped.fastq',
    params:
        adapter=config.get('adapter1')
    threads: 
        config.get('threads_compress')
    # conda:
    #     "./envs/pre_process.yaml"
    log:
        '{output_dir}/log/pre_process/clip_adapter_{sample_id}.log'
    shell:
        '''fastx_clipper \
            -a {params.adapter} \
            -l 13 \
            -Q 33 \
            -v \
            -i {input.fastq} \
            -o {output.fastq}
        '''

rule filter_quality:
    input:
        fastq='{output_dir}/pre_process/{sample_id}.clipped.fastq',
    output:
        fastq='{output_dir}/pre_process/{sample_id}.clipped.filtered.fastq',
    threads: 
        config.get('threads_compress')
    # conda:
    #     "./envs/pre_process.yaml"
    log:
        '{output_dir}/log/pre_process/filter_quality_{sample_id}.log'
    shell:
        '''fastq_quality_filter \
            -q 20 \
            -p 80 \
            -Q 33 \
            -v \
            -i {input.fastq} \
            -o {output.fastq}
        '''

rule collapse_duplicate:
    input:
        fastq='{output_dir}/pre_process/{sample_id}.clipped.filtered.fastq',
    output:
        fastq='{output_dir}/pre_process/{sample_id}.clipped.filtered.collapsed.fa',
    threads: 
        config.get('threads_compress')
    # conda:
    #     "./envs/pre_process.yaml"
    log:
        '{output_dir}/log/pre_process/collapse_duplicate_{sample_id}.log'
    shell:
        '''fastx_collapser \
            -Q 33 \
            -v \
            -i {input.fastq} \
            -o {output.fastq}
        '''


rule barcode_removal:
    input:
        fastq='{output_dir}/pre_process/{sample_id}.clipped.filtered.collapsed.fa',
    output:
        fastq='{output_dir}/pre_process/{sample_id}.clipped.filtered.collapsed.trimmed.fa',
    params:
        barcode_length=config.get('barcode_length')
    threads: 
        config.get('threads_compress')
    # conda:
    #     "./envs/pre_process.yaml"
    log:
        '{output_dir}/log/pre_process/barcode_removal_{sample_id}.log'
    shell:
        '''fastx_trimmer \
            -f {params.barcode_length} \
            -v \
            -i {input.fastq} \
            -o {output.fastq}
        '''
